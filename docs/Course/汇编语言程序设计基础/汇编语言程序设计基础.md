 ## 变量定义
```x86asm
a db 10, 20
b dw 8086h, 0faceh
c dd 8086c0deh
d dq 8086c0dedeadbeefh
e dt 3.1415926535897932
```

分别表示`define byte` `define word` `define double word` `double quadruple word` `define ten byte`
word为16bit，double word为32bit 
**ten byte** 可以用来表示一个小数

## .386和use16的使用
如果想要使用eax ebx等32位寄存器，需要在代码的最开始加上一行`.386`
同时每一个段上要加`use16`才可以使用32位寄存器


## ptr_assume_图形模式编程

### assume
```x86asm
data segment
abc db 1,2,3,4
data ends

code segment
assume cs:code, es:data
;如果出现
; assume cs:code, ds:data, es:data, ss:data
;同一个段与多个段寄存器有关联时:ds > ss > es > cs
main:
   jmp begin;（forward reference 会产生3个字节 其中1个nop）
xyz db 1, 2, 3, 4
begin:
   mov ax, data
   mov es, ax
   ;mov ax, code
   ;mov cs, ax 报错，cs寄存器不能mov赋值
   mov al, abc[1]; 编译后变成mov al, es:[0001]
   ;先替换成mov al, data:[0001]
   ;再替换成mov al, es:[0001]
   ;在替换时编译器并不检查es与data是否相等
   ;假定前面assume ds:data,则这句话就会替换成
   ;mov al, ds:[0001]并简化成mov al, [0001]
   ;因为[]中没有bp时，默认的段地址一定是ds且ds
   ;可以省略。

   mov al, xyz[1]; 编译后变成
			     ; mov al, code:[xyz + 1]
			     ; mov al, code:[3 + 1]
			     ; mov al, code:[4]
			     ; mov al, cs:[4]
   mov ah, 4Ch
   int 21h
code ends
end main
```
**assume**告诉编译器，把data:替换成es，把code:替换成cs

但是assume不会给es 或者cs直接复制，因此我们需要首先cs es赋值
```x86asm
mov ax, data
mov ex, ax
```
但是需要注意的是，这里没有把cs给赋值，因此程序开始会将cs赋值为**code segment**的地址，而且`mov ax, code` `mov cs, ax`会有语法错误

**段地址寄存器** **cs, ds, es, ss**，注意其源操作数不能是常数，只能是寄存器和变量，即只能通过`mov ax, 1000h` `mov ds, ax`来赋值

ds如果没有赋值，那么会自动赋值为`date segment - 10h`
![](images/Pasted%20image%2020240525091515.png)
这里的`10h`实际上就是 psp区域的内容，该区域存储着我们运行程序传入的参数等


### 编译代码的流程
```bash
masm asssmue;
link assume;
td assume.exe
```

## stack_ss_es_fl段
```x86asm
stk segment *stack*; 堆栈段定义只能写一个
a db 0,0,0,...,0 ; 100个0
a db 100, dup(0) ; 这两个相同
db 200h dup('S') ; 无名数组，保留200byte的空间
stk ends 
```
注意需要加上stack，说明这个段是一个stack段


```x86asm
data segment
abc dw 1234h, 5678h
data ends

code segment
assume cs:code, ds:data, ss:stk
;ss和sp的值在程序开始运行时由操作系统自动设定,
;程序员不需要手工对它们进行赋值。
;正如cs:ip也是在程序开始运行时由操作系统进行赋值
;一样。
main:
   mov ax, data
   mov ds, ax
   push abc[0]
   pop abc[2]
   mov ah, 4Ch
   int 21h
code ends

stk segment stack
db 200h dup(0); 或写成dw 100h dup(0)
stk ends
;堆栈空间是stk:0到stk:1FF
;程序开始运行时,ss=stk,sp=1FF+1
; sp和ss的关系，非常类似于cs和ip的关系
end main
```
**段起始地址的**16进制个位必须**0**,否则不能成为段起始地址

因此程序开始时data segment的ds存有2个word，4byte，还需要补全12byte的0，才能让code segment设置为cs的开始

同理，code segment结束后，也是需要保证偏移地址的开始为0，不然的话需要补0

### 如果没有自己定义stack segment
![](images/Pasted%20image%2020240525102029.png)
首段指的是data段，如果首先push一下 `sp - 2 = 0 - 2 = 0xFFFE`
![](images/Pasted%20image%2020240525102227.png)

总体的结构图
![](images/Pasted%20image%2020240525102526.png)


### push 和 pop的使用
![](images/Pasted%20image%2020240525100113.png)
非常的简单 数据结构中有所涉及
push时，先移动sp指针-，然后按照小端的形式写入stack
pop时，先pop出来值，然后移动sp指针+


### es寄存器的使用 以及一些寄存器的总结
**es: extra segment附加段**
```x86xml
data1 segment
abc db 1,2,3
data1 ends

data2 segment
xyz db 4,5,6
data2 ends

code segment
assume cs:code, ds:data1, es:data2
main:
   mov ax, data1
   mov ds, ax
   mov ax, data2
   mov es, ax
   mov ah, abc[1]; 编译后变成mov ah, ds:[1]
   ;也可以写成mov ah, ds:abc[1]
   mov xyz[1], ah; 编译后变成mov es:[1], ah
   ;也可以写成mov es:xyz[1], ah
   ;错误写法:mov abc[1], xyz[1]; 因两个对象不能都为内存变量
   mov ah, 4Ch
   int 21h
code ends
end main
```
因为有两个数据段，所以要分别指定不同的段偏移地址
这里的意思是用es来辅助段地址的使用

![](images/Pasted%20image%2020240525103117.png)

### fl寄存器
FL寄存器一共有16bit
![](images/Pasted%20image%2020240525104013.png)
#### CF的使用
CF(Carry Flag)进位标志
```x86asm
mov ah, 0FFh
add ah, 1; AH = 0, CF = 1有进位
add ah, 2; AH = 2, CF = 0没有进位
sub ah, 3; AH = 0xFFh, CF = 1有借位
; 移位指令也会影响CF的值，最后移出去的那一位会自动保存在CF
mov ah, 10110110B;
shr ah, 1; 该语法要求加入.386
		 ; 并且每个segment后加use16
		 ; AH = 01101100B, CF = 0
shr ah, 2; 保存最后移动出去的那一位 CF = 1
```
总的来说**加法，减法，左移，右移会导致CF的变化**
两条跳转指令`jc jnc`根据CF的值来决定是否跳转

如何获取CF的值？
使用adc指令（add with carry）
```
mov ah, 10110110B; 
shl ah, 1; CF = 1
mov ah, 0;  mov不会干扰任何标志位
adc ah, 0; AH = AH + 0 + CF
```

其他的一些指令
`clc`清空CF = 0
`stc` 设置CF为 1
`adc ax, bx` ax = bx + CF

```
.386
data segment use16
abc dd 12345678h
data ends

code segment use16
assume cs:code, ds:data
main:
	mov ax, data
	mov ds, ax
	mov eax, [abc]
	push eax
	mov cx, 32
next:
	shl eax, 1
	mov dl, 0
	adc dl, '0'
	mov ah, 2
	int 21h
	pop eax
	sub cx, 1
	jnz next
	mov ah, 4Ch
	int 21h
code ends
end main; 用来指定程序从main:开始运行
```

#### ZF的使用Zero flag
```x86asm
sub ax, ax; AX = 0, ZF = 1
add ax, 1; AX = 1, ZF = 0
add ax, 0FFFFh; AX = 0, CF = 1, ZF = 1
```

`jz is_zero`如果是0那么跳转
`jnz is_not_zero`ZF为0跳转
`jz实际上等于je`  `jnz实际上等于jne`

je jne实际上是根据flag来判断是否要跳转

`cmp ax, ax`后，ax的值不会受影响，但是CPU会在内部做减法运算，并且丢弃两数的差，ZF = 1

#### SF符号标志 sign flag其实就是运算结果的最高位
```x86asm
mov ah, 7Fh
add ah, 1 ; AH = 80h = 10000000B SF = 1 最高位
sub ah, 1 ; AH = 7Fh = 01111111B SF = 0
jns positive; 会发生跳转 如果SF为0 就是表示是正数
```
还有指令`js`如果SF == 1那么就跳转

#### OF溢出标志 (overflow flag)
```x86asm
mov ah, 7Fh; 
mov ah, 1  ; AH = 80h, OF = 1, ZF = 0, CF = 0, SF = 1
mov ah, 80h
add ah, 0FFh ; AH = 7Fh, OF = 1, ZF = 0, CF = 1, SF = 0
mov ah, 80h
sub ah, 1; AH = 7Fh, OF = 1, ZF = 0, CF = 0, SF = 0
```
`OF相关的跳转指令` `jo` `jno`  

#### 剩下的参考word文档 比较全面

#### 总结
6个标志状态位置`CF(Carry Flag) ZF(Zero flag) SF(Sign Flag) OF(overflow Flag) AF(Auxiliary Flag辅助进位) PF(Parity Flag奇偶校验)`

3个控制标志`DF Diretion flag` ``
`TF:trace/trap flag`  `IF:interrupt flag`







### main函数内容定义变量
![](images/Pasted%20image%2020240525100736.png)
在函数内部定义变量 前面一定要加上一个`jmp XXX`指令，因为`abc db 0`是伪指令，会有一个数据0，但是编译器会把他翻译成我们不期望的指令，因此需要jmp跳过
### 命令行参数
```
td example.exe 123 456
```
查看`ds::80h`处的内容可以发现，第一个byte为传入参数的长度为8
接下来的byte的意义分别是 空格 1 2 3 空格 4 5 6 （回车）
回车不计算在内
